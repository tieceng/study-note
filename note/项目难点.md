#### redis 的一些难点与选型

背景：业务上需要判断用户是否是首刷，而进行一些策略的排序，由于广告业务性质决定，首刷肯定只出现一次，否则影响数据统计，所以本次需求使用加锁，又由于是 ToC，对性能要求比较高，这种场景下，使用 redis 的 setnx 这种方式是最合适的。
使用 setnx 性能上的一些需要考虑的点

难点：
1.业务上：不能影响业务，譬如首刷一定能保证只出现一次，因此需要加锁，防止并发可能出现的问题
2.不能影响性能，不能有大量的 key 在同一时间失效，譬如说 以用户为标识的 key，到第二天凌晨 几亿的用户 key不能同时失效，影响性能
3.需要原子性操作来保证业务
4.架构上的后续考量

解决：
1.key 的设计
 	有唯一标识，【前缀+计划+uid】，因为同一计划只会设置一次首刷位置的插入，所以这种key 在淘汰时间上随机范围就可以长一些
	key 越长越好，因为 redis 底层是 hash 进行查找 key，因此查找复杂度都是o(1)，key越长hash 冲突概率越小，总体来看，效率越高
2.命令的选择

​	setnx：需要 setnx 与 expire 两次操作，不是原子性的，两次操作过程中可能会有并发问题，由于pipline也不是原子性的，所以无法保证
​	set -nx -ex 是原子性的

3.版本考虑
setnx 在 redis 2.6.12 版本后就被舍弃了，这对业务升级有隐患

因此最终是选择了 set -nx -ex
