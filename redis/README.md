## 数据结构：快速的 redis 有哪些慢操作

提到 redis 我们第一反应就是快，那么为什么快呢？实际上，当 redis 收到一个键值对操作后，能以为秒级别的速度找到数据，并快速完成操作。

那么为什么 redis 这么突出的表现呢：一方面，这是因为它是内存数据库，所有操作都在内存上完成，内存的访问速度本身就很快。另一方面，这要归功于他的数据结构。这是因为，键值对是按一定的数据结构来组织的，操作键值对最终就是对数据结构的增删改查操作，所以高效的数据结构，是 redis 快速处理数据的基础。

### 那么redis 数据结构有哪些呢？

咱们知道的 string（字符串）、list（列表）、hash（哈希）、set（集合）和 sorted set（有序集合），这些其实只是 redis 键值对值的数据类型，也就是数据的保存形式，那他们的底层数据结构是什么呢？

简单来说一共有 6 种，分别是：简单动态字符串、双向链表、压缩列表、哈希表、跳表、和整数数组。他们和数据类型的对应关系如下图：

<img src="https://user-images.githubusercontent.com/19903677/114173194-5749c400-9969-11eb-8810-6b2b195506fa.png" style="zoom:25%;" />

string类型的底层实现之后一种数据结构，也就是简单动态字符串。而 list、hash、set 和 sorted sort 这四种数据类型，都有两种底层实现结构。通常情况下，我们会把这四种类型成为集合类型，他们的特点就是一个键对应了一个集合的数据

那么我们思考一下：

- 这些数据结构都是值的底层实现，键和值本身之间用什么结构组织？
- 为什么集合类型有那么多的地层结构，他们都是怎么组织数据的，都很快吗？
- 什么是简单动态字符串，和常用的字符串是一回事吗？

### 键和值用什么结构组织？

为了实现从键到值的快速访问，redis 使用了一个哈希表来保存所有键值对

一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以我们通常说，一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。

如果值是集合类型的话，作为数组元素的哈希桶该如何保存呢？其实，哈希桶中的元素保存的并不是值本身，而是指向具体值的指针，也就是说，不管值是 string 还是集合类型，哈希桶中的元素都是指向他们的指针。

看下图，哈希桶中的 entry 元素保存了*key 和 *value指针，分别指向了实际的键和值，这样一来，即使值是一个集合，也可以通过 *value 指针被查找到

<img src="https://user-images.githubusercontent.com/19903677/114173991-8f9dd200-996a-11eb-9efa-eae2f4a0e391.png" style="zoom:25%;" />

因为这个哈希表保存了所有的键值对，所以，我也把他称为全局哈希表，哈希表的最大好处很明显，就是让我们可以用 o(1)的时间浮渣度来快速查找到键值对--我们只需要计算键的哈希值，就可以知道他所对应的哈希桶位置，然后就可以访问相应的 entry 元素。所以不管有多少个键，只需要一次计算就能找到相应的键。

但是，如果你只是了解了哈希表的 O(1)浮渣度和快速查找特性，那么，当你往 redis 中写入大量数据后，就可能发现操作有时候会突然变慢了。这其实是因为你忽略了一个潜在的风险点，那就是哈希表的冲突问题和 rehash 可能带来的操作阻塞。

### 为什么哈表操作变慢了？

当你往哈希表中写入更多的数据时，哈希冲突是不可避免的问题，这里的哈希冲突，也就是指，两个 key 的哈希值和哈希桶对应关系式，正好落到了一个哈希桶中。

redis 解决哈希冲突的方式，就是链式哈希。链式哈希也很容易理解，就是指同一个哈希桶中的多个元素用一个链表来保存，他们之间一次用指针链接。

如下图：

<img src="https://user-images.githubusercontent.com/19903677/114174577-60d42b80-996b-11eb-9839-9820e12a47f3.png" style="zoom:25%;" />

Entry1、entry2、entry3 都需要保存在哈希桶 3 中，导致了哈希冲突。此时，entry1 元素会通过一个*next 指针指向 entry2，同样 entry2 也会通过 *next 指向 entry3，我们也可以通过 entry 元素中的滋镇，把他们链接起来，这就行程了一个链表，也叫做哈希冲突表。

但是存在一个问题，哈希冲突链上的元素只能通过指针逐一查找再操作。如果哈希表里写入的数据越来越多，哈希冲突可能也会越来越多，这就会导致某些哈希冲突链过长，进而导致这个链上的元素查找耗时长，效率低。对于追求“块”的 redis 涞水，这是不太能接受的。

所以，redis 会对哈希表进行 rehash 操作。rehash 也就是增加现有的哈希桶数量，让逐渐增加的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量。从而减少单个桶中的冲突。那么如何做呢？

为了使 rehash 操作更高效，redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始当你插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有分配空间，随着数据逐步增多，redis 开始执行 rehash，这个过程分为三步：

1. 给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的 2 倍
2. 把哈希表1 中的数据重新映射并拷贝到哈希表 2 中 ；
3. 释放哈希表 1 的空间

到此，我们就可以从哈希表 1 切换到哈希表 2，用增大的哈希表 2 保存更多的数据，而原来的哈希表 1 留作下一次 rehash 扩容备用。

这个过程看似简单，但是第二部涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 redis 线程阻塞，无法服务其他请求。

为了避免这个问题，redis 采用了渐进式 rehash

简单来说，就是在进行第二步拷贝数据时，redis 仍然正常处理客户端请求。每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等下一个请求时，在顺带拷贝哈希表 1 中的下一个索引位置的 entries。如下图

<img src="https://user-images.githubusercontent.com/19903677/114175848-089e2900-996d-11eb-8d97-cfe936a69a5c.png" style="zoom:55%;" />

这样就巧妙的把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，，保证了数据的快速访问

以上就是 redis 键和值是怎么通过哈希表组织的了，对于 string 类型来说，找到哈希桶就能直接增删改查了，所以哈希表的 O（1）操作复杂度也就是他的复杂度了； 

但是对于集合类型来说，及时找到了哈希桶还要在集合中在进一步操作，接下来，我们来看集合类型的操作效率又是怎样的？

### 集合数据操作效率

和 string 类型不同买一个集合类型的值，第一步是通过全局哈希表找到对应的哈希桶位置，第二步是在集合中在增删改查，那么，集合的操作效率和那些因素相关呢？

首先，与集合的底层数据结构有关。例如，使用哈希表实现的集合，要比使用链表实现的集合访问效率更高，其次，操作效率和这些操作本身的执行特点有关系，比如读写一个元素的操作要比读写所有元素的效率高。

接下来，我们就分别聊聊集合类型的底层数据结构和操作复杂度

### 有哪些底层数据结构？

刚才，说过，技术类型的底层数据结构主要有 5 种：整数数组、双向链表、哈希表、压缩列表和跳表

其中哈希表的操作特点我们刚才已经学过了；整数数组和双向链表也很常见，他们的操作特征都是顺序读写，也就是通过数组下表或者链表的指针逐个元素访问，操作复杂度基本是 O(N)，操作效率比比较低；压缩列表和跳表我们平时解除的不多，但他们也是 redis 中重要的数据结构，那么我来解释一下；

压缩列表类似一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 zlbytes、zltail和 zllen，分表标识列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表位还有一个 zlend，标识列表结束。

<img src="https://user-images.githubusercontent.com/19903677/114176898-56676100-996e-11eb-8e0d-2c888488ec9c.png" style="zoom:55%;" />

在压缩列表中，我们查找定位第一个和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)、而查找其他元素时。就没有这么高效了，只能逐个查找。此时复杂度就是 O(N)了。

我们再来看下跳表

有序链表就只能逐一查找元素，导致操作起来非常缓慢，于是就出现了跳表。具体来说跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转。数显数据的快速定位。如下图

<img src="https://user-images.githubusercontent.com/19903677/114177209-b4944400-996e-11eb-8ebe-0727b97ce73d.png" style="zoom:55%;" />

我们要在链表中查找 33 这个元素，只能从头开始便利链表，查找 6 次，知道找到 33 位置。此时，浮渣度是 o(n),查找效率很低。

为了提高查找速度，我们来增加一级索引：从第一个元素开始，每两个元素选出一个来作为索引。这些索引在通过指针指向原始的链表。例如，从前两个元素中抽取元素 1 作为以及索引，从带三、四个元素中抽取元素 11 作为一级索引。此时我们只需要 4 次查找就能定位到元素 33 了。

如果我们还想再快，可以再增加二级索引：从以及索引中，在抽取部分元素作为耳机索引。例如，从一级索引中抽取 1、27、100 作为二级索引，二级索引指向一级索引。这样我们只需要 3 次查找，就能定位到元素 33 了。

可以看到，这个查找过程就是在多级索引上跳来跳去，最后定位到元素。这也正好符合“跳”表的叫法。当数据量很大时，跳表的查找复杂度就是 o(logN)。

好了，我们想着可以按照查找的时间复杂度给这些数据结构分下类了：

<img src="https://user-images.githubusercontent.com/19903677/114272695-c1d23100-9a49-11eb-89a5-c99ec73061d1.png" style="zoom:25%;" />

### 不同操作的复杂度

集合类型的操作类型很多，有读写单个集合元素的，例如 HGET、HSET，也有操作多个元素的，例如 SADD，还有对整个集合进行遍历操作的，例如 SMEMBERS。这么多操作，他们的复杂度也各不相同，而复杂度的高低又是我们选择集合类型的重要依据。

我总结了一个四字口诀，希望能帮助你快速记住集合常见操作的复杂度。这样你在使用过程中，就可以提前规避高复杂度操作了。

- 单元素操作是基础
- 范围操作非常耗时
- 统计操作通常高效
- 例外情况只有几个

第一，单元素操作，是指每一种集合类型对单个数据实现的增删改查操作。例如，Hash 类型的 HGET、HSET 和 HDEL。Set 类型的 SADD、SREM/SRANDMEMBER 等。这些操作的复杂度由集合采用的数据结构决定的。例如 HGET、HSET、HDEL是对哈希表做操作。所以他们的复杂度都是 O(1)；Set 类型用哈希表作为底层数据结构时，它的 SADD、SREM、SRANDMEMBER 复杂度也是 O(1)。

这里，有个地方需要注意一下，集合类型支持同时对多个元素进行增删改查，例如 Hash 类型的 HMGET 和 HMSET，set 类型的 sadd 也支持同时增加多个元素，此时这些操作的复杂度，就是由单个元素操作复杂度和元素个数决定的。例如，HMSET 增加 M 个元素时，复杂度就从 O(1)变成 O(M)了

第二，范围操作，是指集合类型中的遍历操作，可以返回集合中的所有数据，比如 Hash 类型的 hgetall 和 set 类型的 smembers，或者返回一个范围内的部分数据，比如 list 类型的 lrange 和 zset 类型的 zrange，这类操作的复杂度一般是 O(N),比较耗时，我们还应该避免

不过redis 从 2.8 版本开始提供了 scan 系列操作，（包含 hscan，sscan 和 zscan）这类操作实现了渐进式遍历。每次只返回有限数据的量，这样一来，相比较 hgetall、smembers 这类操作来说，就避免了一次性返回所有元素而导致的 redis 阻塞。

第三，统计操作，是指集合类型对集合中所有元素个数的记录。例如 llen 和 scard。这类操作复杂度只有 o(1)，这是因为当集合类型采用压缩列表。双向链表。整数数组这些数据结构时。这些结构中专门记录了元素的个数统计，因此可以高效的完成相关操作。

第四，例外情况，是指某些数据结构的特殊记录。例如压缩列表和双向列表都会记录表头和表尾的偏移量。这样一来，对于 list 类型的 lpop、rpop。lpush、rpush 这四个操作来说，他们是在列表的头尾删除元素，这就考验通过偏移量直接定位，所以他们的复杂度也只有 O(1)，可以是先快速操作

### 总结

1. 底层数据结构

   1. 保存每个键和值的全局哈希表结构
   2. 支持集合类型实现的双向链表、压缩列表、整数数组、哈希表和跳表这五大底层结构

2. redis 之所以能快速操作键值对，一方面是因为 O(1)复杂度的哈希表被广泛使用，包括 string、hash 和 set，他们的操作复杂度基本都用哈希表决定，另一方面，sorted set 也采用了 O(logN)复杂度的跳表。不过，集合类型的范围操作，因为要遍历底层数据结构，复杂度通常是 O(N)。这里。我的建议是：用其他命令来替代，例如可以用 scan 来代替，避免在 redis 内部产生费时的拳击和遍历操作。

3. 当然，我们不能忘了复杂度较高的 list 类型，他的两种底层实现结构：双向链表和压缩列表的操作复杂度都是 O(N)。一次， 我的简易式：因地制宜地使用 list 类型，例如，既然它的 pop/push小懒虫很高，那么就将它主要用于 FIFO 队列场景，而不是作为一个可以随机读写的集合。

   
