## 高性能 IO 模型：为什么单线程Redis能那么快？

redis 的单线程只要是只 redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 redis 对外提供键值存储服务的主要流程。但是 redis 的其他功能，比如持久化、一步删除、集群数据同步等，是由额外的线程来执行的。

所以严格来说 redis 不是单线程。

### 为什么用单线程？为什么单线程能这么快？

我们来看下一下 redis 单线程设计机制以及多路复用机制

### redis 为什么使用单线程？

更好对了姐 redis 为什么用单线程，我们要了解多线程的开销

#### 多线程的开销

日常写程序时，使用多线程有一下优点“使用多线程，可以增加系统吞吐率，看也增加系统拓展性”，在合理的资源分配情况下，增加系统中处理请求操作的资源你尸体，进而提升系统能够处理的请求书，即吞吐率。

<img src="https://user-images.githubusercontent.com/19903677/113002322-3bddfc80-91a4-11eb-90e4-2562b78a96c4.png" alt="ab9a384d70578236800ceaa8e58ff45c" style="zoom:25%;" />



注意！如果没有良好的系统设计，实际得到的结果，其实是右图所展示的那样。我们开始增加线程数时，视同吞吐率会增加，但是在进一步增加线程时，系统吞吐率就增长迟缓了，甚至还会出现下降的情况？

为什么出现这种情况呢？一个关键的瓶颈在于。系统中通常会存在被多线程同时访问的共享资源，比如一个共享的数据结构，当有多个线程修改这个资源时，为了保证共享资源的正确性，就需要有额外的机制进行保证，那么就会带来额外的开销。

拿 redis 来说，redis 的 List 数据类型，提供出队（LPOP) 和入队（Lpush）操作，如果使用多线程 A 和 B 一个入队，并且长度+1，一个出队，并且长度-1，为了保证队列长度的正确性，需要 线程 A 和 B 的 Lpush 和 Lpop 串行执行，否则我们就会得到错误的长度结果。这就是**多线程编程模式面临的共享资源的并发访问控制问题**

<img src="https://user-images.githubusercontent.com/19903677/113003081-f79f2c00-91a4-11eb-8292-64bc3a895f18.png" alt="ab9a384d70578236800ceaa8e58ff45c" style="zoom:25%;" />

并发访问控制一直是多线程开发中的一个难点问题，如果没有精细的设计，如果只是简单的采用了一个粗粒度互斥锁，即使增加了线程，大部分线程也在等待获取访问共享资源的互斥锁，并行变串行，系统的吞吐率并没有随着线程的增加而增加。

而且采用多线程一般会引入保护共享资源的并发访问，这降低了代码的易调试性和可维护性。因此 redis 直接采用了单线程的模式

### 单线程 redis 为什么那么快？

一般来说，单线程的处理能力比多线程差很多，但是 redis 却能使用单线程模型达到每秒数十万级别的处理能力，这是为什么呢？

1. redis 操作大部分在内存上完成，在加上他采用了高效的数据结构，例如哈希表和跳表。
2. redis **采用了多路复用机制**，使其在网络 IO 才做中能并发处理大量的客户端请求，实现高吞吐率

首先我们要明白网络操作的基本 IO 模型和潜在的阻塞点，毕竟，redis 采用单线程进行 IO。如果线程被阻塞了，就无法进行多路复用了

#### 基本 IO 模型与阻塞点

一般的请求（get）会有以下过程

1. 监听客户团请求（bind/listen）
2. 和客户端建立连接（accept）
3. 从 socket 中读取请求（recv）
4. 解析客户端发送请求（parse）
5. 根据请求类型读取兼职数据（get）
6. 最后给客户端返回结果，即向 socket 中写回数据（send）
