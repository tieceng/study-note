### Stream使用文档

#### 一、stream概念

- stream是Redis 5.0版本引入的一个新的数据类型，它以更抽象的方式模拟*日志数据结构* ，可以理解为一个放在内存中的日志流
- tream是Redis的数据类型中最复杂的，尽管数据类型本身非常简单，它实现了额外的非强制性的特性：提供了一组允许消费者以阻塞的方式等待生产者向Stream中发送的新消息。
- 此外还有一个名为**消费者组**的概念。目标：允许一组客户端相互配合来消费同一个Stream的不同部分的消息。
- stream和lists数据结构没什么太大的不同，就是附加的特性、API更复杂，更强大
- 我们还可以使用一种完全不同的方式来看待一个Stream：不是作为一个消息传递系统，而是作为一个*时间序列存储*。

![20201204143228844](https://user-images.githubusercontent.com/19903677/133588735-3a1c30a2-dbf8-4a55-8adb-5d86cef43c25.png)


#### 二、stream的增删改查

##### XADD

```
> XADD mystream * sensor-id 1234 temperature 19.8
1518951480106-0
```

调用了**XADD**命令往名为`mystream`的Stream中添加了一个条目`sensor-id: 123, temperature: 19.8`，使用了自动生成的条目ID，也就是命令返回的值，具体在这里是`1518951480106-0`。命令的第一个参数是key的名称`mystream`，第二个参数是用于唯一确认Stream中每个条目的条目ID。然而，在这个例子中，我们传入的参数值是`*`，因为我们希望由Redis服务器为我们自动生成一个新的ID。

1518951480106-0 （<millisecondsTime>-<sequenceNumber>）这是由服务器本地时间毫秒时间戳生成的唯一ID，前面是毫秒时间戳，后面是自增ID，如果有并发，那么这个ID则会+1，但是如果当前毫秒时间戳比以前的条目时间戳小的话，那么会使用以前的条目时间，所以即便是服务器时钟向后跳，单调增长ID的特性仍然会保持不变。

XADD也可以带上自己定义的ID 

```
> XADD somestream 0-1 field value
0-1
> XADD somestream 0-2 foo bar
0-2
```



请注意，在这种情况下，最小ID为0-1，并且命令不接受等于或小于前一个ID的ID：

```
> XADD somestream 0-1 foo bar
(error) ERR The ID specified in XADD is equal or smaller than the target stream top item
```



##### XLEN

```
> XLEN mystream
(integer) 1
```

##### 按范围查询: XRANGE 和 XREVRANGE

要根据范围查询Stream，我们只需要提供两个ID，即*start* 和 *end*。返回的区间数据将会包括ID是start和end的元素，因此区间是完全包含的。两个特殊的ID`-` 和 `+`分别表示可能的最小ID和最大ID。

```
> XRANGE mystream - +
1) 1) 1518951480106-0
   2) 1) "sensor-id"
      2) "1234"
      3) "temperature"
      4) "19.8"
2) 1) 1518951482479-0
   2) 1) "sensor-id"
      2) "9999"
      3) "temperature"
      4) "18.2"
```

返回的每个条目都是有两个元素的数组：ID和键值对列表。我们已经说过条目ID与时间有关系，因为在字符`-`左边的部分是创建Stream条目的本地节点上的Unix毫秒时间，因此我们可以根据这个ID进行毫秒级别的范围查询

```
> XRANGE mystream 1518951480106 1518951480107
1) 1) 1518951480106-0
   2) 1) "sensor-id"
      2) "1234"
      3) "temperature"
      4) "19.8"
```

这边有可选参数 COUNT

```
> XRANGE mystream - + COUNT 2
1) 1) 1519073278252-0
   2) 1) "foo"
      2) "value_1"
2) 1) 1519073279157-0
   2) 1) "foo"
      2) "value_2"
```

如果想迭代着查询，需要设定star值

```
> XRANGE mystream 1519073279157-1 + COUNT 2
1) 1) 1519073280281-0
   2) 1) "foo"
      2) "value_3"
2) 1) 1519073281432-0
   2) 1) "foo"
      2) "value_4"
```

依此类推。由于**XRANGE**的查找复杂度是*O(log(N))*，因此*O(M)*返回M个元素，这个命令在count较小时，具有对数时间复杂度，这意味着每一步迭代速度都很快。所以**XRANGE**也是事实上的*流迭代器*并且不需要**XSCAN**命令。

**XREVRANGE**命令与**XRANGE**相同，但是以相反的顺序返回元素，因此**XREVRANGE**的实际用途是检查一个Stream中的最后一项是什么：

```
> XREVRANGE mystream + - COUNT 1
1) 1) 1519073287312-0
   2) 1) "foo"
      2) "value_10"
```

请注意：**XREVRANGE**命令以相反的顺序获取*start* 和 *stop*参数。

##### XREAD

提供监听到达Stream的新消息的能力的命令称为**XREAD**。比**XRANGE**要更复杂一点，所以我们将从简单的形式开始，稍后将提供整个命令布局。

```
> XREAD COUNT 2 STREAMS mystream 0
1) 1) "mystream"
   2) 1) 1) 1519073278252-0
         2) 1) "foo"
            2) "value_1"
      2) 1) 1519073279157-0
         2) 1) "foo"
            2) "value_2"
```

以上是**XREAD**的非阻塞形式。注意**COUNT**选项并不是必需的，实际上这个命令唯一强制的选项是**STREAMS**，指定了一组key以及调用者已经看到的每个Stream相应的最大ID，以便该命令仅向客户端提供ID大于我们指定ID的消息

在上面的命令中，我们写了`STREAMS mystream 0`，所以我们想要流 `mystream`中所有ID大于`0-0`的消息。正如你在上面的例子中所看到的，命令返回了键名，因为实际上可以通过传入多个key来同时从不同的Stream中读取数据。我可以写一下，例如：`STREAMS mystream otherstream 0 0`。注意在**STREAMS**选项后面，我们需要提供键名称，以及之后的ID。因此，**STREAMS**选项必须始终是最后一个。

我们可以通过指定**BLOCK**参数，轻松地将**XREAD** 变成一个 *阻塞命令*：

```
> XREAD BLOCK 0 STREAMS mystream $
```

请注意，在上面的例子中，除了移除**COUNT**以外，我指定了新的**BLOCK**选项，超时时间为0毫秒（意味着永不超时）。此外，我并没有给流 `mystream`传入一个常规的ID，而是传入了一个特殊的ID`$`。这个特殊的ID意思是**XREAD**应该使用流 `mystream`已经存储的最大ID作为最后一个ID。以便我们仅接收从我们开始监听时间以后的*新*消息。这在某种程度上相似于Unix命令`tail -f`。

请注意当使用**BLOCK**选项时，我们不必使用特殊ID`$`。我们可以使用任意有效的ID。如果命令能够立即处理我们的请求而不会阻塞，它将执行此操作，否则它将阻止。通常如果我们想要从新的条目开始消费Stream，我们以`$`开始，接着继续使用接收到的最后一条消息的ID来发起下一次请求，依此类推。

#### 消费者组

当手头的任务是从不同的客户端消费同一个Stream，那么**XREAD**已经提供了一种方式可以*扇形分发*到N个客户端，还可以使用从节点来提供更多的读取可伸缩性。

然而，在某些问题中，我们想要做的不是向许多客户端提供相同的消息流，而是从同一流向许多客户端提供*不同的消息子集*。这很有用的一个明显的例子是处理消息的速度很慢：能够让N个不同的客户端接收流的不同部分，通过将不同的消息路由到准备做更多工作的不同客户端来扩展消息处理工作。

消费者组就像一个*伪消费者*，从流中获取数据，实际上为多个消费者提供服务，提供某些保证：

1. 每条消息都提供给不同的消费者，因此不可能将相同的消息传递给多个消费者。
2. 消费者在消费者组中通过名称来识别，该名称是实施消费者的客户必须选择的区分大小写的字符串。即便断开连接过后，消费者组仍然保留了所有的状态，因为客户端会重新申请成为相同的消费者。这也意味着由客户端提供唯一的标识符。
3. 每一个消费者组都有一个*第一个ID永远不会被消费*的概念，也就是消费者消费的信息不会重复消费
4. 消费消息需要使用特定的命令进行显式确认，表示：这条消息已经被正确处理了，所以可以从消费者组中读丢弃
5. 消费者组跟踪所有当前所有待处理的消息，也就是，消息被传递到消费者组的一些消费者，但是还没有被确认为已处理。由于这个特性，当访问一个Stream的历史消息的时候，每个消费者*将只能看到传递给它的消息*。

- ##### **XGROUP** 用于创建，摧毁或者管理消费者组。

- **XREADGROUP** 用于通过消费者组从一个Stream中读取。

- **XACK** 是允许消费者将待处理消息标记为已正确处理的命令。、

##### 创建一个消费者组

假设我已经存在类型流的 `mystream`，为了创建消费者组，我只需要做：

```
> XGROUP CREATE mystream mygroup $
OK
```

当创建一个消费者组的时候，我们必须指定一个ID，在这个例子中ID是`$`。这是必要的，因为消费者组在其他状态中必须知道在第一个消费者连接时接下来要服务的消息，即消费者组创建完成时的*最后消息ID*是什么？如果我们就像上面例子一样，提供一个`$`，那么只有从现在开始到达Stream的新消息才会被传递到消费者组中的消费者。如果我们指定的消息ID是`0`，那么消费者组将会开始消费这个Stream中的*所有*历史消息。当然，你也可以指定任意其他有效的ID。你所知道的是，消费者组将开始传递ID大于你所指定的ID的消息。因为`$`表示Stream中当前最大ID的意思，指定`$`会有只消费新消息的效果。

##### **XREADGROUP**

我们会从消费者那里读到，假设指定消费者分别是Alice和Bob，来看看系统会怎样返回不同消息给Alice和Bob。

**XREADGROUP**和**XREAD**非常相似，并且提供了相同的**BLOCK**选项，除此以外还是一个同步命令。但是有一个*强制的*选项必须始终指定，那就是**GROUP**，并且有两个参数：消费者组的名字，以及尝试读取的消费者的名字。选项**COUNT**仍然是支持的，并且与**XREAD**命令中的用法相同。

假如我创建消息：

```
> XADD mystream * message apple
1526569495631-0
> XADD mystream * message orange
1526569498055-0
> XADD mystream * message strawberry
1526569506935-0
> XADD mystream * message apricot
1526569535168-0
> XADD mystream * message banana
1526569544280-0
```

请注意：*在这里message是字段名称，apple是关联的值，记住Stream中的每一项都是小字典。*

```
> XREADGROUP GROUP mygroup Alice COUNT 1 STREAMS mystream >
1) 1) "mystream"
   2) 1) 1) 1526569495631-0
         2) 1) "message"
            2) "apple"
```

表示我想要使用消费者组`mygroup`从Stream中读取，我是消费者`Alice`。每次消费者使用消费者组中执行操作时，都必须要指定可以这个消费者组中唯一标识它的名字。

注意：强制选项是**STREAMS**，键`mystream`请求的ID是特殊的ID `>`。这个特殊的ID只在消费者组的上下文中有效，其意思是：**消息到目前为止从未传递给其他消费者**。

但是也可以指定一个真实的ID，比如`0`或者任何其他有效的ID，在这个例子中，我们请求**XREADGROUP**只提供给我们**历史待处理的消息**。所以基本上**XREADGROUP**可以根据我们提供的ID有以下行为：

如果ID是特殊ID`>`，那么命令将会返回到目前为止从未传递给其他消费者的新消息，这有一个问题，就是会更新消费者组的*最后ID*。 如果ID是任意其他有效的数字ID，那么命令将会让我们访问我们的*历史待处理消息*。即传递给这个指定消费者（由提供的名称标识）的消息，并且到目前为止从未使用**XACK**进行确认。

我们可以立即测试此行为，指定ID为0，不带任何**COUNT**选项：我们只会看到唯一的待处理消息，即关于apples的消息：

```
> XREADGROUP GROUP mygroup Alice STREAMS mystream 0
1) 1) "mystream"
   2) 1) 1) 1526569495631-0
         2) 1) "message"
            2) "apple"
```

但是，如果我们确认这个消息已经处理，它将不再是历史待处理消息的一部分，因此系统将不再报告任何消息：

```
> XACK mystream mygroup 1526569495631-0
(integer) 1
> XREADGROUP GROUP mygroup Alice STREAMS mystream 0
1) 1) "mystream"
   2) (empty list or set)
```

假如Bob来消费

```
> XREADGROUP GROUP mygroup Bob COUNT 2 STREAMS mystream >
1) 1) "mystream"
   2) 1) 1) 1526569498055-0
         2) 1) "message"
            2) "orange"
      2) 1) 1526569506935-0
         2) 1) "message"
            2) "strawberry"
```

Bob要求最多两条消息，并通过同一消费者组`mygroup`读取。，消息”apple”未被传递，因为它已经被传递给Alice，所以Bob获取到了orange和strawberry，以此类推。

这样，Alice，Bob以及这个消费者组中的任何其他消费者，都可以从相同的Stream中读取到不同的消息，读取他们尚未处理的历史消息，或者标记消息为已处理。这允许创建不同的拓扑和语义来从Stream中消费消息。

有几件事需要记住：

- 消费者是在他们第一次被提及的时候自动创建的，不需要显式创建。
- 即使使用**XREADGROUP**，你也可以同时从多个key中读取，但是要让其能够工作，你需要给每一个Stream创建一个名称相同的消费者组。这并不是一个常见的需求，但是需要说明的是，这个功能在技术上是可以实现的。
- **XREADGROUP**命令是一个*写命令*，因为当它从Stream中读取消息时，消费者组被修改了，所以这个命令只能在master节点调用。

#### 三、异常处理

上面的例子允许我们编写多个消费者参与同一个消费者组，每个消费者获取消息的一个子集进行处理。然而在现实世界中，消费者有可能永久地失败并且永远无法恢复。由于任何原因停止后，消费者的待处理消息会发生什么呢？

##### **XPENDING**

调用这个命令只需要两个参数，即Stream的名称和消费者组的名称。

```
> XPENDING mystream mygroup
1) (integer) 2
2) 1526569498055-0
3) 1526569506935-0
4) 1) 1) "Bob"
      2) "2"
```

命令只会输出给定消费者组的待处理消息总数（在本例中是两条消息），所有待处理消息中的最小和最大的ID，最后是消费者列表和每个消费者的待处理消息数量。我们只有Bob有两条待处理消息，因为Alice请求的唯一一条消息已使用**XACK**确认了。

我们可以通过给**XPENDING**命令传递更多的参数来获取更多信息，完整的命令如下：

```
XPENDING <key> <groupname> [<start-id> <end-id> <count> [<conusmer-name>]]
```

通过提供一个开始和结束ID（可以只是`-`和`+`，就像**XRANGE**一样），以及一个控制命令返回的信息量的数字，我们可以了解有关待处理消息的更多信息。如果我们查看指定消费组的待处理消息，可以使用最后一个可选参数，即消费者组的名称。

```
> XPENDING mystream mygroup - + 10
1) 1) 1526569498055-0
   2) "Bob"
   3) (integer) 74170458
   4) (integer) 1
2) 1) 1526569506935-0
   2) "Bob"
   3) (integer) 74170458
   4) (integer) 1
```

上面的命令输出每一条消息的详细信息：消息ID，消费者名称，*空闲时间*（单位是毫秒，意思是：自上次将消息传递给某个消费者以来经过了多少毫秒），以及每一条给定的消息被传递了多少次。我们有来自Bob的两条消息，它们空闲了74170458毫秒，大概20个小时。

如果我们想查看第一条信息的详情

```
> XRANGE mystream 1526569498055-0 1526569498055-0
1) 1) 1526569498055-0
   2) 1) "message"
      2) "orange"
```

我们只需要在参数中重复两次相同的ID。假如，Alice 认为过了20个小时，Bob仍然没有处理这些消息，由这个来判断Bob无法及时恢复，所以要认领待处理的消息，代替Bob进行处理。为了做到这一点，我们使用**XCLAIM**命令。



这个命令非常的复杂，有很多选项，因为它用于复制消费者组的更改，但我们只使用我们通常需要的参数。

```
XCLAIM <key> <group> <consumer> <min-idle-time> <ID-1> <ID-2> ... <ID-N>
```

对于这个特定的Stream和消费者组，我希望指定的ID的这些消息可以改变他们的所有者，并将被分配到指定的消费者`<consumer>`。但是，我们还提供了最小空闲时间，因此只有在上述消息的空闲时间大于指定的空闲时间时，操作才会起作用，有可能两个客户端会同时尝试认领一条消息：

```
Client 1: XCLAIM mystream mygroup Alice 3600000 1526569498055-0
Clinet 2: XCLAIM mystream mygroup Lora 3600000 1526569498055-0
```

认领一条消息的问题是会重置它的闲置时间！并将增加其传递次数的计数器，所以上面第二个客户端的认领会失败。通过这种方式，我们可以避免对消息进行简单的重新处理。

下面是命令执行的结果：

```
> XCLAIM mystream mygroup Alice 3600000 1526569498055-0
1) 1) 1526569498055-0
   2) 1) "message"
      2) "orange"
```

Alice成功认领了该消息，现在可以处理并确认消息，尽管原来的消费者还没有恢复，也能继续工作。

从上面的例子很明显能看到，作为成功认领了指定消息的副作用，**XCLAIM**命令也返回了消息数据本身。但这不是强制性的。可以使用**JUSTID**选项，以便仅返回成功认领的消息的ID。如果你想减少客户端和服务器之间的带宽使用量的话，以及考虑命令的性能，这会很有用，并且你不会对消息感兴趣，因为稍后你的消费者的实现方式将不时地重新扫描历史待处理消息。

认领也可以通过一个独立的进程来实现：这个进程只负责检查待处理消息列表，并将空闲的消息分配给看似活跃的消费者。可以通过Redis Stream的可观察特性获得活跃的消费者。

##### 消息认领及交付计数器

在**XPENDING**的输出中，你所看到的计数器是每一条消息的交付次数。这样的计数器以两种方式递增：消息通过**XCLAIM**成功认领时，或者调用**XREADGROUP**访问历史待处理消息时。

但有时候处理特定的消息会出现问题，因为消息会以触发处理代码中的bug的方式被损坏或修改。在这种情况下，消费者处理这条特殊的消息会一直失败。因为我们有传递尝试的计数器，所以我们可以使用这个计数器来检测由于某些原因根本无法处理的消息。所以一旦消息的传递计数器达到你给定的值，比较明智的做法是将这些消息放入另外一个Stream，并给系统管理员发送一条通知。

##### XINFO：Streams 的可观察性

缺乏可观察性的消息系统很难处理。不知道谁在消费消息，哪些消息待处理，不知道给定Stream的活跃消费者组的集合，使得一切都不透明。

**XINFO**命令是一个可观察性接口，可以与子命令一起使用，以获取有关Stream或消费者组的信息。

这个命令使用子命令来显示有关Stream和消费者组的状态的不同信息，比如使用**XINFO STREAM **可以报告关于Stream本身的信息。

```
> XINFO STREAM mystream
 1) length
 2) (integer) 13
 3) radix-tree-keys
 4) (integer) 1
 5) radix-tree-nodes
 6) (integer) 2
 7) groups
 8) (integer) 2
 9) first-entry
10) 1) 1524494395530-0
    2) 1) "a"
       2) "1"
       3) "b"
       4) "2"
11) last-entry
12) 1) 1526569544280-0
    2) 1) "message"
       2) "banana"
```

输出显示了有关如何在内部编码Stream的信息，以及显示了Stream的第一条和最后一条消息。

```
> XINFO GROUPS mystream
1) 1) name
   2) "mygroup"
   3) consumers
   4) (integer) 2
   5) pending
   6) (integer) 2
2) 1) name
   2) "some-other-group"
   3) consumers
   4) (integer) 1
   5) pending
   6) (integer) 0
```

**XINFO**命令输出一系列键值对。因为这是一个可观察性命令，允许用户了解报告的信息，并允许命令通过添加更多字段来报告更多信息，而不会破坏与旧客户端的兼容性。其他更高带宽效率的命令，比如**XPENDING**，只报告没有字段名称的信息。

我们可以通过检查在此类消费者组中的消费者，来更详细地检查特定消费者组的状态。

```
> XINFO CONSUMERS mystream mygroup
1) 1) name
   2) "Alice"
   3) pending
   4) (integer) 1
   5) idle
   6) (integer) 9104628
2) 1) name
   2) "Bob"
   3) pending
   4) (integer) 1
   5) idle
   6) (integer) 83841983
```

如果你不记得命令的语法，可以查看帮助：

```
> XINFO HELP
1) XINFO <subcommand> arg arg ... arg. Subcommands are:
2) CONSUMERS <key> <groupname>  -- Show consumer groups of group <groupname>.
3) GROUPS <key>                 -- Show the stream consumer groups.
4) STREAM <key>                 -- Show information about the stream.
5) HELP                         -- Print this help.
```



#### 四、淘汰策略

##### **XADD**命令的**MAXLEN**

```
> XADD mystream MAXLEN 2 * value 1
1526654998691-0
> XADD mystream MAXLEN 2 * value 2
1526654999635-0
> XADD mystream MAXLEN 2 * value 3
1526655000369-0
> XLEN mystream
(integer) 2
> XRANGE mystream - +
1) 1) 1526654999635-0
   2) 1) "value"
      2) "2"
2) 1) 1526655000369-0
   2) 1) "value"
      2) "3"
```

如果使用**MAXLEN**选项，当Stream的达到指定长度后，老的条目会自动被淘汰，因此Stream的大小是恒定的。

然而使用**MAXLEN**进行修整代价可能比较大：Stream由宏节点表示为基数树，以便非常节省内存。改变由几十个元素组成的单个宏节点不是最佳的。因此可以使用以下特殊形式提供命令：

```
XADD mystream MAXLEN ~ 1000 * ... entry fields here ...
```

在选项**MAXLEN**和实际计数中间的参数`~`的意思是，我不是真的需要精确的1000个项目。它可以是1000或者1010或者1030，只要保证至少保存1000个项目就行。通过使用这个参数，仅当我们移除整个节点的时候才执行修整。 

还有**XTRIM**命令可用，它做的事情与上面讲到的**MAXLEN**选项非常相似，但是这个命令不需要添加任何其他参数，可以以独立的方式与Stream一起使用。

```
> XTRIM mystream MAXLEN 10
```

或者，对于**XADD**选项：

```
> XTRIM mystream MAXLEN ~ 10
```

是，**XTRIM**旨在接受不同的修整策略，虽然现在只实现了**MAXLEN**。将来有可能允许按时间来进行修整。

